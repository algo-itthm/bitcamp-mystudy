휴가: 5층 행정데스크 방문신청
wifi: Aipalm202_2G / aipalm_202
웨일온: 210 866 3081 / 111222
엄진영 강사님: jinyoung.eom@gmail.com
Git: https://github.com/eomjinyoung/bitcamp-study



2024-05-24(금)
CPU가 RAM에서 명령과 데이터를 받아 처리, 이때 명령과 데이터를 S/W로 칭함

S/W는 System S/W와 Application S/W로 구분
  - System S/W: H/W 제어 (OS, 드라이버, 임베디드, IoT 등)
  - Application S/W
    > Standalone: 외부 S/W의 도움 없이 실행 (MS Office, Photoshop 등)
    > Client/Server: 외부 S/W와 통신 필요 (카카오톡, 메일 등)
       설치형과 비설치형으로 세부 구분되며, 그 중 비설치형인 Web Application이 수업목표

Web Application
  - 웹브라우저가 웹서버로부터 HTML, CSS, JS, images 등을 내부적으로 다운받아 실행
  - 정적 파일을 그냥 다운받을 수도 있지만, java 등을 통해 동적으로 작성하여 다운받을 수 있음

CLI: Command Line Interface / 글자를 이용하여 명령을 내리는 방식


2024-05-27(월)
GIT: 소프트웨어 형상관리 시스템 (S/W Configuration Management System / SCM)
  - 버전관리라고도 칭하는데, 버전이란 변경에 대해 번호를 부여하는 것
  - clone. add, commit, push, pull
  - .gitignore을 활용하여 백업대상에서 특정파일 제외 가능
  - 초기 commit 시 email, username 설정 필요 / 초기 push 시 username, password 설정
    github에서 access token 발행하여 사용

Virtual Box와 Vagrant 사용하여 가상 OS 띄우기

CPU, 기계어, OS의 관계
  - CPU는 동일하지만 OS가 다를 경우, 각 OS마다 요구하는 포맷이 다르기 때문에 각각의 OS에 맞추어 컴파일 필요
  - OS는 동일하지만 CPU가 다를 경우에도 각각의 CPU마다 별도 컴파일 필요


2024-05-28(화)
애플리케이션 개발 방식
  - 컴파일 : 소스코드 -> (컴파일) -> 기계어 -> (실행) -> OS
  - 인터프리트 : 소스코드 -> (로드) -> 인터프리터 -> (실행) -> OS
  - 하이브리드 : 자바의 경우 소스코드를 클래스로 컴파일한 후, JVM을 통해 인터프리트 방식으로 실행

  > 컴파일 방식은 OS에 따라 별도로 컴파일해야 한다는 단점이 있고
     인터프리트 방식은 실행할 때마다 소스파일이 있어야 하고, 매번 문법검사가 진행되어 속도 저하, 실행 전에는 문법 오류를 알 수 없음
  > 하이브리드 방식은 컴파일 시 문법 검사를 하며, 기계어와의 유사함으로 실행 속도가 빠르고 한번의 컴파일로 여러 OS에서 실행 가능

크롬은 V8 Javascript 엔진, Blink HTML/CSS 렌더링 엔진이 포함되어 있다.
  - Blink 엔진은 Safari에 있는 Webkit HTML/CSS 렌더링 엔진을 개선한 것

JRE (Java Runtime Environment) : JVM + 실행할 때 사용하는 도구
컴파일러, 디버거, 프로파일러, 문서생성기 등 개발관련 도구를 JRE와 합쳐 만든 것이 JDK

Java SE (Standard Edition) : JRE, ServerJRE, JDK
Java EE (Enterprise Edition) : 웹 App. 개발도구, 분산 App. 개발도구, 자원관리도구, 테스트용 서버 등
Java ME (Micro Edition) : Embedded App. 개발도구

EE 실행요건
1. 다중사용자가 이용 -> Servlet, JSP, JSTL, EL, JSF 등 Web App. 제작도구
2. App.의 분산 배치 -> 분산 컴포넌트 제작도구


2024-05-29(수)
VSCode Java 포매팅
  - 폰트는 네이버 D2Coding 폰트 사용
  - 저장 시 auto formatting 적용 (구글 기준)
  - code lens 해제, inlay hint 해제

javac -encoding UTF-8 [파일명]
  - 소스파일이 어떤 규칙에 따라 문자를 저장했는지 컴파일러에게 알려줌
javac -d [폴더경로] [파일명]
  - class 파일을 저장할 폴더 지정
java -classpath (-cp) [폴더경로] [파일명]
  - class 파일의 위치를 JVM에게 알려줌
javac -target [버전] [파일명]
  - 컴파일 후 실행할 버전을 지정

jdk-17까지는 Windows에서 한글이 들어간 java 파일을 컴파일하려 하면 오류 발생
  - vscode는 utf-8로 파일을 저장하지만 Windows는 MS949 형식으로 텍스트를 읽기 때문에
    소스파일이 MS949로 저장되었을 거라 추측 -> 컴파일 오류 발생
  - javac 에서 -encoding 옵션으로 해결

소스파일 폴더와 컴파일 결과파일 폴더 분리
  - 통상 소스파일은 src, 컴파일 결과는 bin 하위에 보관

개발관리
  - 개발관리의 편의를 위해 각 응용프로그램을 프로젝트로 구분

프로젝트와 디렉토리
  - 프로젝트별로 src 폴더. bin 폴더 구분
  - src 폴더는 main과 test로 구분, 하위에는 사용언어에 따라 java, kotlin 등으로 구분

Git 저장소와 프로젝트 폴더
  - 통상 저장소 하나당 프로젝트 하나
  - 하나의 저장소에 여러 프로젝트를 둘 경우, 저장소 단위로 버전이 관리되기 때문에
    개별 프로젝트 단위 관리가 어려움
  - 하나의 메인 프로젝트와 여러 서브 프로젝트를 두는 것은 가능

빌드란?
  - 소스코드를 실행 가능한 소프트웨어로 변환하는 과정
  - 컴파일 -> 링크 -> 테스트 -> 패키징 -> 배포
     API 문서 생성 포함
  - 자바는 빌드도구가 JDK를 통해 컴파일, API 문서생성, 단위테스트, 패키징(Jar) 등을 수행

  Ant : build.xml
  Maven : pom.xml / 의존 라이브러리 관리기능 추가
  Gradle : build.gradle / 빌드 과정을 정교하게 제어할 수 있도록 프로그래밍 언어로 빌드스크립트 작성
              gradle은 maven 호환이기 때문에 의존 라이브러리 저장소 사용 가능

  jar : java archive / 자바 실행과 관련된 파일을 한 파일로 묶은 것
  war : web archive
  tar : tape archive

  DSL : Domain-Specific Language

gradle init
gradle compileJava (컴파일만 수행)
gradle build (-i : info 출력)
gradle clean
gradle run (-q : 결과만 출력)


2024-05-30(목)
Java Class 파일은 16진수 바이트코드로 구성
  - sublime 텍스트 에디터를 사용해 HelloWorld.class 직접 작성 체험
  - javap = 클래스파일 분석

자바 기초 프로그래밍
  - 명령문 -> 함수 -> 클래스 -> 패키지 -> 모듈
  - 라이브러리 : 다른 개발자가 만들어 컴파일해 둔 코드 (.lib, .dll - Windows, .so - Linux, Unix)
  - 로더 : OS가 프로그램 실행 시 기계어를 메모리에 로딩해주고 main()을 호출하는 보조코드
  - C언어는 소스파일을 컴파일한 후 라이브러리와 묶어 실행파일로 linking


2024-05-31(금)
  - 어셈블리 한줄은 기계어 한줄과 매핑되기에, 통상 어셈블리 코딩을 기계어 코딩이라 칭함
  - C언어 컴파일 시 gcc는 어셈블리어로 컴파일하고, 어셈블러가 이를 기계어로 컴파일함
  - Java에서는 bytecode viewer에서 보이는 내용이 어셈블리어 역할을 암

자바 패키지
  - 클래스를 분류하는 문법

주석
  - /* */ traditional comment와 // end-of-line comment
  - /**  */ 형식으로 주석을 사용하면 javadoc 실행 시 API 문서를 만듦
  * API는 클래스나 메소드의 설명이 담긴 Interface 문서
javadoc -encoding UTF-8 -charset UTF-8 -d docs -sourcepath app/src/main/java com.eomcs.lang.ex02

Annotation
  - 컴파일러나 JVM에게 전달하는 특별한 정보
  - annotation 주석은 .class 파일에 포함될 수 있음

Literal
  - 값을 표현한 것
  - 상세 설명은 pdf 참고
  - 2진수는 0b, 8진수는 0, 16진수는 0x를 맨 앞에 붙여 표기
  - 부동소수점 지수 표기법: 숫자 뒤에 e + 지수


2024-06-03(월)

줄바꿈
  - Linux/Unix : LF만 사용 (0x0A)
  - Windows : CRLF 사용 (0x0D 0x0A)

문자 집합
  - ISO-8859-1 : ASCII(7비트)에서 1비트를 추가하여 표기 / 한글 표기 불가 (저장 시 ?로 표기)
  - EUC-kR : 2바이트 / 한글 2,350자만 표기 가능 (천리안/하이텔에서 사용)
  - 조합형 : 5비트 초성, 중성, 종성을 조합 / 맨 앞의 1비트가 1이면 한글 / 조합한 후 4비트씩 나누어 표현
                국제표준이 아니며, 16비트의 절반을 한글이 사용하여 타언어 표현이 어려움
                EUC-KR과 호환되지 않음 / 아래아한글에서 사용
  - MS949 : Windows 95부터 EUC-KR 2,350자에 더하여 총 11,172자를 정의
                국제표준이 아니어서 Windows에서만 사용 가능 (Linux/Unix 불가)
  - Unicode : 최대 4바이트 중 21비트를 사용하여 문자를 표기 (0x000000 ~ 0x10FFFF)
                   UTF-16 은 2바이트이며, 자바에서 문자를 다룰 때 사용 (UTF-16 Big Endian 방식)
                   전세계 문자를 새로 지정하였으며, 알파벳도 2byte로 표현한다는 단점이 있어 UTF-8 등장
  - UTF-8 : 비트 패턴에 따라 1바이트부터 4바이트로 문자를 표기
               알파벳은 ASCII 와 동일하게 1바이트로, 한글은 3바이트로 표현
               자바에서 문자열을 저장할 때 사용

인코딩/디코딩
  - A값을 B값으로 변환(인코딩)하거나 되돌리는(디코딩) 방식
  - 인코더와 디코더를 합쳐 CODEC 이라 칭함

% 인코딩 : URL 내 특정 문자를 안전하게 표시하기 위한 인코딩 방식

숫자 저장 방식
  - Sign-Magnitude 방식 (부호 절대값) : 부호비트와 절대값 활용 / 부동소수점 가수부 저장 시 사용
  - 1의 보수 : 각 비트의 반대값으로 보수를 구성 / 사용하지 않음
  - 2의 보수 : 1의 보수 + 1 / 정수 저장 시 사용
  - Excess-K : bias 값을 더하여 저장 / bias k = 2^(비트수 - 1) - 1 / 부동소수점의 지수부를 저장할 대 사용
    즉 8비트 기준으로 K값은 2^(8-1) - 1 = 127
    최소값은 127 + (-127) = 0 / 최대값은 127 + 128 = 255이 되어 순차적으로 정렬 가능

부동소수점 방식 (floating-point)
  - 10진수 값을 IEEE-754에 따라 2진수로 변환
    12.375 변환 시 소수점 뒤의 값은 2를 곱한 값이 1 이상인지를 비교하여 계산
    1100.011을 구한 후 정규화 수행 => 1.100011 * 2^3
    가수부는 100011, 지수부는 excess-k를 적용하여 3 + 127(bias) = 130 = 10000010
    => 32비트 기준, 부호비트 1비트 + 지수부 8비트 10000010 + 가수부 23비트 100011
    => 0100 0001 0100 0110 0000 0000 0000 0000 => 41 46 00 00


2024-06-04(화)
변수 (Variables)
  - 데이터를 저장하는 메모리
  - 변수 선언 : 메모리를 준비시키는 명령

데이터 타입
  - Primitive Data Types : 정수(byte, short, int, long), 부동소수점(float, double), 논리(boolean), 문자(char)
  - User Defined Data Types : 클래스
  - 역할 : 메모리 사용 제어 / 같은 숫자를 저장하더라도 int냐 float이냐에 따라 저장값은 달라짐
  - byte b = -128 이라고 할 때, -128이라는 정수 리터럴은 4바이트 int값이 기본
    원래 1바이트인 byte 변수에 4바이트를 저장할 수 없지만, 리터럴은 저장할 수 있는 값이라면 컴파일러가 허용함
  - 소수점에 관계 없이 float은 대략 7자리까지, double은 대략 15자리까지 "거의 정확하게" 저장 가능
    이를 유효자릿수라 부르며, 이를 초과하면 값이 일부분만 저장될 가능성이 높음 / 따라 8바이트 사용이 권장됨

이클립스
  - 이클립스로 프로젝트 import 시 특정 설정파일이 필요 (.project / .classpath 등)
  - build.gradle 에 이클립스 플러그인 설정 가능
  - 설정 후 gradle tasks 를 입력하면 사용가능한 task 확인 가능
  - [File] - Import - Working Directory 선택 후 .project 파일이 있는 폴더 선택


2024-06-05(수)
IntelliJ
  - settings.gradle 파일로 프로젝트 오픈
  - Scanner 사용 시, gradle로 실행하면 키보드 표준입력을 받지 못하고 실행이 종료됨
    이 경우 build.gradle에 standardInput으로 System.in 을 받도록 설정해야 함

해시코드 체크 : certutil -hashfile "대상파일" "알고리즘"

자바 패키지
  - 패키지명은 조직명, 제품명, 역할명 등으로 구성
    조직명으로 사용할 시 Domain Name을 거꾸로 사용 (com.microsoft / com.bitcamp 등) / 폴더 구분 용이

마크다운 (README.md)
  - HTML 태그보다 간결한 방식으로 문서 형식을 지정하기 위해 만든 포맷
  - #, ## 등으로 제목을 표시하며, HTML로 변환 시 각각 h1, h2 등 태그로 변환됨

리팩토링
  - 의미 있는 변수명 사용하기


2024-06-07(금)
연산자
  - 산술연산자 : +. -. *. /, %
  - 증감연산자 : ++, --
  - 관계연산자 : <, <=, >, >=, instanceof
  - 등가연산자 : ==, !=
  - 논리연산자 : &&, ||, ! (+ boolean에 한해 &, | 를 포함하기도 함)
  - 비트연산자 : &, |, ^, ~
  - 비트이동연산자 : <<. >>, >>>
  - 대입연산자 : =, +=, -=, *=, /=, %=, &=, !=, ^=, <<=, >>=, >>>=
  - 삼항연산자 : 조건 ? 값1 : 값2

연산 관련 학습
  - 서로 다른 타입의 연산
    -> 연산은 같은 타입만 가능하며, 타입이 다르면 컴파일러가  타입을 맞춘 후 연산을 수행 (imlicit type conversion)
    -> 개발자가 명시적으로 타입을 변환할 수 있다. (explicit type conversion)
    -> 정수는 부동소수점에, 작은 크기의 값은 큰 크기의 값에 타입을 맞춤
         byte. char. short --> int --> long --> float --> double
    -> 형변환 시 값이 잘릴 수 있다는 점 유의
  - 연산의 결과는 항상 int로 변환
    -> 즉, byte 타입의 변수 둘의 연산을 수행하면 그 결과는 int 가 됨
  - 만약 int의 범위를 초과하는 값의 연산을 long 변수에 대입하려 한다면 음수가 출력됨 (오버플로우가 먼저 발생)

Statement & Expression
  - Statement : 어떤 작업을 수행하는 단위
  - Expression : 값을 반환하는 문장


2024-06-10(월)
조건문
  - 자바에는 if ~ else if ~ else 구문이 존재하지 않으며, if ~ else 문을 줄맞춤한 것에 불과
  - switch case 문에서 case 값으로는 리터럴만 가능 / 변수는 컴파일 시 값이 정해지지 않아 불가
    하지만 상수는 가능 (final int GUEST = 0;)  com.eomcs.lang.ex06.Exam0241 참고

배열
  - 배열의 각 요소에는 메모리의 주소가 저장됨 / 각 요소는 객체 또는 인스턴스라 칭함
  - 배열은 배열 메모리의 주소를 저장하는 변수로서, 레퍼런스라고 칭함
  - 배열의 최대 크기는 Integer.MAX_VALUE - 2 와 같음 (VM Limit)

배열 레퍼런스와 가비지
  - 메모리 사용량이 일정수준 이상 증가하면, 사용하지 않는 객체를 JVM이 자동 감지하여 제거
  - Reference Counting : 객체의 참조 횟수를 추적하여 0이 되면 제거
  - Reference Tracing : 참조 추적 알고리즘을 사용하여 객체의 참조여부 분석


2024-06-11(화)
